import sys
import numpy as np
import scipy as sp
import matplotlib.pyplot as plt
from scipy.special import factorial, comb
from scipy.stats import binom

def poisson_prob(lam, k):
    # Gives the probability that a number, k, will be drawn from a poisson
    # distribution with the expected number of occurences lam (lambda).
    return lam**k * np.exp(-lam) / factorial(k)

def perturb_prob(m, n, p, real, k):
    """
    Gives the probability that exactly k of a certain row will be generated by
    perturbation.
        m: total number of possible rows
        n: total number of peers (number of actual rows)
        p: probability that each peer will randomly perturb their row
        real: real number of a certain row present in the dataset
        k: the number of that certain row for which we are trying to assess the probability
    """
    little_p = (1.0 - p) / m
    real_p = p + little_p

    mass = 0

    # probability that i of the real rows will be present
    for i in range(real + 1):
        # chances that exactly i of the real value holders will report that
        # value
        mass_i = binom.pmf(i, real, real_p)
        # chance that exactly k - i of the non-real value holders will report
        # that value
        mass_j = binom.pmf(k - i, n - real, little_p)
        mass += mass_i * mass_j

    return mass

if __name__ == '__main__':
    m = 2000
    n = 10000
    p = float(sys.argv[1])
    delta = 0.001

    fig, ax = plt.subplots(1, 1)
    real_vals = range(20)
    epsilons = np.zeros(len(real_vals))

    for real in real_vals:
        X = np.arange(0, 100)
        y1 = map(lambda k: perturb_prob(m, n, p, real, k), X)
        y2 = map(lambda k: perturb_prob(m, n, p, real+1, k), X)
        last_elt = np.argmax(np.cumsum(y2) > (1 - delta))
        y1 = y1[:last_elt]
        y2 = y2[:last_elt]
        X = X[:last_elt]
        ratios = map(lambda k: max(y1[k], y2[k]) / min(y1[k], y2[k]), X)
        epsilons[real] = np.log(max(ratios))

    ax.plot(real_vals, epsilons)
    plt.show()
